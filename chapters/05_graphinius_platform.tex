\chapter{Graphinius as a platform}
\label{ch:graphinius_platform}

This section contains an overview description of the proposed Graphinius platform and some of its core features envisioned, as well as basic graph-theoretical properties it will support.


\section{General Properties}
\label{sect:general_properties}
	
	\subsection{Online editor}
	\label{ssect:online_editor}
	
		Front-end web-developers know the great joys and advantages tools like \textit{JSFiddle} or \textit{CodePen} provide: Simply by navigating to their site or - more commonly - being referred to an 'experiment' via a link somebody has posted, one is presented with an online code editor supporting HTML5, CSS and JS on one side of the browser, and a live result window on the other. The code gets executed as soon as it has finished loading, and the live result is updated on every save (and sometimes every few seconds). In modern browsers those tools go as far as being able to preview and live-reload complex scenes written in WebGL, which was the author's basic inspiration to come up with a graph-theoretical counterpart.
	
	\subsection{Build \& mutate}
	\label{ssect: build_edit}
	
	As a consequence, one should be able to go to the Graphinius website, be presented with a console that is pre-loaded with all background objects and functionality needed to build, interact with, mutate and visualize graphs. Upon making changes to the underlying graph structure in the Online Code Editor (which would follow the REPL principle: Read-evaluate-print-loop) the live-visualization will update immediately, so a CodePen-like workflow is offered to the user. This feature - although not yet implemented in a particular UI - is partly already available simply by using the debugging console every modern browser provides.
		
	\subsection{Save and fork experiments}
	\label{ssect: save_fork_exps}
	
	Following the online web-developer coding example platforms mentioned above, Graphinius will enable users to change experiments, automatically forking them in the background. This way, every user can compile their own extendable library of exchangeable graph experiments over time.		
	
	\subsection{Distributable via (mini) URL}
	\label{ssect:distribute_url}
	
	Sharing ones insights with colleagues (investors, the public...) or preparing a live demonstration should be as easy as pressing a 'publish' button upon a mini URL would be generated by the platform. Then simply publish or email that URL to somebody and re-create your experiment on any device capable of handling HTML5 / WebGL through a modern browser anywhere!	
	
	\subsection{Example graph datastructures}
	\label{ssect:pre_settings}
	
	In order to help users get started with new experiments, we will provide a database of example graph structures, covering graphs from diverse fields of potential interest (traffic infrastructure graphs, protein interaction networks, sample social networks) as well as different graph classes (tree-shaped graphs, disconnected components, spherical graphs etc.).
	
	\subsection{Extendable algorithm DB}
	\label{ssect:ext_algo_db}
	In the process of working on their experiments, users of the platform will undoubtedly come op with their own graph-theoretical algorithms. In order not to squander those pearls, Graphinius will provide a community-based, extendable algorithm DB which people can upload their algorithms to (with a description of necessary pre- and postconditions), so that other users can easily choose from a wealth of graph-theoretical computations.


\section{Graph Properties}
\label{sect:graph_properties}

	\subsection{Mixed mode graph}
	\label{ssect:mixedmode}
	A mixed mode graph is a graph that may contain directed as well as undirected edges at the same time. While many algorithms are defined on just undirected (e.g. Minimum spanning tree) or directed (e.g. percolation) edges exclusively, for many real world applications it is required to consider a combination of both - imagine traffic simulations with one-way streets or social networks in which people can be friends (undirected) and / or follow each other (directed). As Graphinius should be able to cover such applications, its core needs to be designed as a mixed-mode graph; the problem with this is that many algorithms have no standard implementation for a mix of both edge types, and so here and there it was necessary to come up with a logical and pragmatic solution, even if it could not be verified by any textbook.
	
	
	\subsection{Node and edge types (filters)}
	\label{ssect:node_types}	
	A mixed-mode graph alone however, is not enough for more complex scenarios. Assuming a social network again, we would first think of humans as participating entities. Depending on the particular use case of the network however, other nodes might be resources such as books, movies, or any type of commodity. Moreover, edges in such a network cannot only differ in mode of direction, but might represent a specific type as well (following someone vs. movie recommendation). From this emerges the need for graph filtering - or graph views - which expose only a specified subgraph to an executing algorithm, suitable to the particular situation. To stay with our example, if we need to find all users within three hops of friendship connections, we do not want to traverse all the edges representing recommendations (or messages, as there might be orders of magnitudes more of those present). In this case, we would execute a Breath-first-search against a view of the graph, which would present the BFS's logic with only the connections it is required to 'see'.
	
	
	\subsection{Object oriented}
	\label{ssect:oo}
	One design decision in writing any new (graph) library - as far as the author can judge from his personal research - lies in speed and memory vs usability. This concerns not so much the handling of nodes and edges themselves (many libraries have very good wrapper functions for dealing with basic primitives), but requirements like additional payload - e.g. the k-gram vector of a node representing a text document - or node \& edge types themselves. In order to speed up execution of graph algorithms, advanced libraries use specialized data types like sparse matrices or fixed-length arrays; this on the other hand forces a programmer to hold additional data structures at hand for whenever more complex computations are needed. A good example for this would be computing the 'distance' of two nodes when defined not as the length of the shortest path between them, but as the cosine distance between their feature vectors. Taking into account the special language properties of JavaScript with its great emphasis on first-order functions and closures which makes it ideal for a natural callback-driven algorithmic approach (see Listings ~\ref{lst:traversal_cb} and ~\ref{lst:traversal_cb_exec}), the author believes that an object oriented approach realized in JavaScript idiomatic callback style is the suitable one for Graphinius, which is backed by 3 different properties of the language:
	
	\begin{itemize}
		\item Despite not being 'traditionally' object oriented like Java or C++ for its absence of constructs like classes etc., Javascript is firmly OO - in fact, everything except primitives is always an object, including and especially functions.
		
		\item Accessing objects instead of flat memory should not incur too much runtime overhead anymore, since modern JSVMs have abandoned the flat model in favor of an object memory model themselves.
		
		\item As Graphinius is intended to be part of a learning, teaching and research platform, and not designed to handle large graphs of many millions of nodes and edges (upwards), the OO approach seems a natural fit since it allows implementing algorithms in a very intuitive way - Meaning that the programmer can access all properties of graph objects directly via their methods instead of having to handle diverse, different datastructures (sparce matrices, lists, hashmaps) in coordination.
	\end{itemize}
